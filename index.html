<!doctype html><html lang="en"><head><meta charset="utf-8"><script src="https://d3js.org/d3.v5.min.js"></script><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/appgroupe14/favicon.ico"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"><title>React App</title><link href="/appgroupe14/static/css/main.40b4a62f.css" rel="stylesheet"></head><body><div id="root"></div><div class="row"><div class="col-sm-8"><script>var svg = d3.select("body").append("svg")
             .attr("width", 960)
             .attr("height", 500)
       
           
           
           
             // Déclaration des variables
             var matrix = [];
             var VisuX = null;
             var VisuY = null;
             var color = null;
           
            
           //Fonction créant la matrice
           function createAdjacencyMatrix(nodes,edges) {
             var edgeHash = {};
             for (x in edges) {
               var id = edges[x].source + "-" + edges[x].target;
               edgeHash[id] = edges[x];
             }
             matrix = [];
            maxY = nodes.length-1;
            
             //create all possible edges
            for (const [a, node_a] of nodes.entries()) {
               for ([b, node_b] of nodes.entries()) {
                   b = maxY - b;
               var grid = {id: node_a.id + "-" + node_b.id, x: a, y:  b, sharedfollowers: 0};
               if (edgeHash[grid.id]) {
                 grid.sharedfollowers = parseInt(edgeHash[grid.id].sharedfollowers);
               }
               matrix.push(grid);
               }
             }
             return matrix;
           }
           
           
           
           //chargement des données
           d3.csv("https://lyondataviz.github.io/teaching/lyon1-m2/2019/data/liens.csv").then(function(edges){
           d3.csv("https://lyondataviz.github.io/teaching/lyon1-m2/2019/data/noeuds.csv").then(function(nodes){
             var matrix = createAdjacencyMatrix(nodes, edges);
             color = d3.scaleLinear().range(["#edf8e9","#006d2c"]).domain([
                 d3.min(matrix, function(d) { return d.sharedfollowers; }),
                 d3.max(matrix, function(d) { return d.sharedfollowers; })
             ]);
             
             var matriceElt = d3.select("svg")
               .append("g")
               .attr("transform", "translate(50,50)")
               .attr("id", "adjacencyMatrix")
               .selectAll("rect")
               .data(matrix)
               .enter()
               .append("rect")
             //Taille de nos cases = 25px
               .attr("width", 25)
               .attr("height", 25)
               .attr("x", function (d) {return d.x * 25})
               .attr("y", function (d) {return d.y * 25})
               .style("stroke", "black")
               .style("stroke-width", ".5px")
               .style("fill", function (d) {return color(d.sharedfollowers)})
             //Ajout de l'aide visuelle avec le mouseover sur les deux axes VisX et VisY
               .on("mouseover", function(d){
                  VisX.style('display', 'block').transition()
                  .attr('y', d.y * 25);
                  VisY.style('display', 'block').transition()
                    .attr('x', d.x * 25);
               });
             var scaleSize = nodes.length * 25; 
             
               x = d3.scaleBand()
                   .domain(nodes.map(function (el) {return el.id}))
                   .range([0, scaleSize])
               
               y = d3.scaleBand();
               
                 y.domain(nodes.map(function (el) {return el.id}))
               
               y.range([scaleSize, 0]);
             
               d3.select("#adjacencyMatrix")
                 .append("g")
                 .attr("transform", `translate(0,225)`)
                 .call(d3.axisBottom(x))
                 .selectAll("text")
                   .attr("transform", function(d) {
                       return "translate(15,15) rotate(45)" 
                       });      
       
             d3.select("#adjacencyMatrix")
               .append("g")
               .call(d3.axisLeft(y))
             
             
             //visu (rect) pour les deux axes
             
             VisX = d3.select("#adjacencyMatrix").append( "rect" )
                       .attr('x', 0)
                       .attr('y', 0)
                       .attr('width', 225)
                       .attr('height', 25)
                       .attr('fill', 'none')
                       .attr('style', 'stroke: black; stroke-width: 2px; display: none');
             VisY = d3.select("#adjacencyMatrix").append( "rect" )
                       .attr('x', 0)
                       .attr('y', 0)
                       .attr('width', 25)
                       .attr('height', 225)
                       .attr('fill', 'none')
                       .attr('style', 'stroke: black; stroke-width: 2px; display: none');
             
           });
           
           });</script></div><div class="col-sm-4"><script>var svg = d3.select("body").append("svg")
             .attr("width", 960)
             .attr("height", 500)
       
           
           
           
             // Déclaration des variables
             var matrix = [];
             var VisuX = null;
             var VisuY = null;
             var color = null;
           
            
           //Fonction créant la matrice
           function createAdjacencyMatrix(nodes,edges) {
             var edgeHash = {};
             for (x in edges) {
               var id = edges[x].source + "-" + edges[x].target;
               edgeHash[id] = edges[x];
             }
             matrix = [];
            maxY = nodes.length-1;
            
             //create all possible edges
            for (const [a, node_a] of nodes.entries()) {
               for ([b, node_b] of nodes.entries()) {
                   b = maxY - b;
               var grid = {id: node_a.id + "-" + node_b.id, x: a, y:  b, sharedfollowers: 0};
               if (edgeHash[grid.id]) {
                 grid.sharedfollowers = parseInt(edgeHash[grid.id].sharedfollowers);
               }
               matrix.push(grid);
               }
             }
             return matrix;
           }
           
           
           
           //chargement des données
           d3.csv("https://lyondataviz.github.io/teaching/lyon1-m2/2019/data/liens.csv").then(function(edges){
           d3.csv("https://lyondataviz.github.io/teaching/lyon1-m2/2019/data/noeuds.csv").then(function(nodes){
             var matrix = createAdjacencyMatrix(nodes, edges);
             color = d3.scaleLinear().range(["#edf8e9","#006d2c"]).domain([
                 d3.min(matrix, function(d) { return d.sharedfollowers; }),
                 d3.max(matrix, function(d) { return d.sharedfollowers; })
             ]);
             
             var matriceElt = d3.select("svg")
               .append("g")
               .attr("transform", "translate(50,50)")
               .attr("id", "adjacencyMatrix")
               .selectAll("rect")
               .data(matrix)
               .enter()
               .append("rect")
             //Taille de nos cases = 25px
               .attr("width", 25)
               .attr("height", 25)
               .attr("x", function (d) {return d.x * 25})
               .attr("y", function (d) {return d.y * 25})
               .style("stroke", "black")
               .style("stroke-width", ".5px")
               .style("fill", function (d) {return color(d.sharedfollowers)})
             //Ajout de l'aide visuelle avec le mouseover sur les deux axes VisX et VisY
               .on("mouseover", function(d){
                  VisX.style('display', 'block').transition()
                  .attr('y', d.y * 25);
                  VisY.style('display', 'block').transition()
                    .attr('x', d.x * 25);
               });
             var scaleSize = nodes.length * 25; 
             
               x = d3.scaleBand()
                   .domain(nodes.map(function (el) {return el.id}))
                   .range([0, scaleSize])
               
               y = d3.scaleBand();
               
                 y.domain(nodes.map(function (el) {return el.id}))
               
               y.range([scaleSize, 0]);
             
               d3.select("#adjacencyMatrix")
                 .append("g")
                 .attr("transform", `translate(0,225)`)
                 .call(d3.axisBottom(x))
                 .selectAll("text")
                   .attr("transform", function(d) {
                       return "translate(15,15) rotate(45)" 
                       });      
       
             d3.select("#adjacencyMatrix")
               .append("g")
               .call(d3.axisLeft(y))
             
             
             //visu (rect) pour les deux axes
             
             VisX = d3.select("#adjacencyMatrix").append( "rect" )
                       .attr('x', 0)
                       .attr('y', 0)
                       .attr('width', 225)
                       .attr('height', 25)
                       .attr('fill', 'none')
                       .attr('style', 'stroke: black; stroke-width: 2px; display: none');
             VisY = d3.select("#adjacencyMatrix").append( "rect" )
                       .attr('x', 0)
                       .attr('y', 0)
                       .attr('width', 25)
                       .attr('height', 225)
                       .attr('fill', 'none')
                       .attr('style', 'stroke: black; stroke-width: 2px; display: none');
             
           });
           
           });</script></div></div><script type="text/javascript" src="/appgroupe14/static/js/main.d70ef7ae.js"></script></body></html>